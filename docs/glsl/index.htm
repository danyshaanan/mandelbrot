<!DOCTYPE html>
<html lang=en>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
<style>
body { text-align: center; margin: 0px; font-family: monospace; font-size: 14px; }
canvas { margin: 40px; border: 1px solid black; }
</style>
</head>
<body>

<h4>
Drag to move<br/>
Right/left click to zoom<br/>
Hover the Mandelbrot (left) to set the C value in the rational map z => z<sup>2</sup> + C used by the Julia (right)<br/>
<br />
<a id=dl-mandl href=''>Download Mandelbrot</a> |
<a id=dl-julia href=''>Download Julia</a> |
<a href='index.htm'>Reset</a> |
<a href='?2e-7,-1.39414,.00252,5e-5,81e-6,-0.002'>Example</a> |
<a href='?1.65e-8,-1.1848,0.3029,0.0002,0.005,0.002'>Example</a> |
Colors: <select><option value=0>default</option><option value=1>sin</option><option value=2>b/w</option></select>
</h4>
<hr />
<canvas id=mandl width=600 height=600></canvas>
<canvas id=julia width=600 height=600></canvas>

<script id='FRAGMENT_SHADER' type='webgl'>
precision highp float;

uniform bool julia;
uniform vec2 generator;
uniform vec2 size;
uniform vec2 origin;
uniform float zoom;
uniform float theme;

vec2 z;
float len, r = pow(2.0, 3.0);

vec2 transform(vec2 p) {
  return zoom * (p - size / 2.0) + origin;
}

vec2 square(vec2 z) {
  return vec2(pow(z.x, 2.0) - pow(z.y, 2.0), 2.0 * z.x * z.y);
}

float iterations(vec2 c) {
  z = julia ? c : vec2(0, 0);
  for (int i = 0; i < 800; i++) {
    z = square(z) + (julia ? generator : c);
    len = length(z);
    if (len > r) return float(i) - log(len) / log(r);
  }
  return 0.0;
}

float hue2c(float p, float q, float t) {
  t = mod(t, 6.0);
  if (t < 1.0) return p + (q - p) * t;
  if (t < 3.0) return q;
  if (t < 4.0) return p + (q - p) * (4.0 - t);
  return p;
}

vec4 hslToRgba(float h, float s, float l) {
  if (s == 0.0) return vec4(l, l, l, 1.0);
  float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
  float p = 2.0 * l - q;
  h = h * 6.0;
  return vec4(
    hue2c(p, q, h + 2.0),
    hue2c(p, q, h      ),
    hue2c(p, q, h + 4.0),
    1
  );
}

float h, s, l, t;
float fadeRange = 50.0;

float wave(float x) {
  return 0.5 + 0.5 * cos(x);
}

vec4 color(float it) {
  if (it == 0.0) return vec4(0, 0, 0, 1);
  l = min(1.0, (800.0 - it) / fadeRange);
       if (theme == 0.0) return hslToRgba(it / 240.0, 1.0, .5 * l);
  else if (theme == 1.0) return vec4(wave(.2 * it), wave(.3 * it), wave(.5 * it), 1);
  else if (theme == 2.0) return hslToRgba(0.0, 0.0, l * wave(3.141592 * log(it)));
}

void main() {
  gl_FragColor = color(iterations(transform(gl_FragCoord.xy)));
}
</script>

<script id='VERTEX_SHADER' type='webgl'>
attribute vec4 position;

void main() {
  gl_Position = position;
}
</script>

<script>
'use strict'

function webglCanvas(id, shaders, def, onLocChange) {
  const canvas = document.getElementById(id)
  const half = { W: canvas.width / 2, H: canvas.height / 2 }

  const gl = canvas.getContext('webgl')
  const prog = gl.createProgram()

  shaders.forEach(({id, text}) => {
    const shader = gl.createShader(gl[id])
    gl.shaderSource(shader, text)
    gl.compileShader(shader)
    gl.attachShader(prog, shader)
  })

  gl.linkProgram(prog)
  gl.useProgram(prog)

  const state = {}
  ;['zoom', 'origin', 'size', 'julia', 'generator', 'theme'].forEach(k => state[k] = gl.getUniformLocation(prog, k))

  gl.uniform2f(state.size, canvas.width, canvas.height)
  gl.uniform1f(state.i, def.i)
  gl.uniform1f(state.julia, id === 'julia')

  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
  gl.bufferData(gl.ARRAY_BUFFER, Float32Array.of(1, 1, -1, 1, 1, -1, -1, -1), gl.STATIC_DRAW)
  gl.enableVertexAttribArray(0)
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)

  const draw = _ => {
    onLocChange()
    gl.uniform1f(state.theme, +document.querySelector('select').value)
    gl.uniform1f(state.zoom, def.zoom)
    gl.uniform2f(state.origin, ...def.origin)
    gl.uniform2f(state.generator, ...def.generator)
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
  }

  const getDiff = (e1, e2) => {
    const [x, y] = [e1.layerX - e2.layerX, e1.layerY - e2.layerY]
    return { x, y, r: Math.hypot(x, y) }
  }

  const zoomAround = (zoom, ev) => {
    def.origin[0] += (ev.offsetX - half.W) * def.zoom
    def.origin[1] -= (ev.offsetY - half.H) * def.zoom
    def.zoom *= zoom
    def.origin[0] -= (ev.offsetX - half.W) * def.zoom
    def.origin[1] += (ev.offsetY - half.H) * def.zoom
  }

  const cToS = c => c.map(x => x.toPrecision()).join('+').replace('+-', '-')
  document.getElementById(`dl-${id}`).onclick = _ => {
      draw()
      _.target.href = canvas.toDataURL()
      _.target.download = `${id}_g${cToS(def.generator)}o${cToS(def.origin)}z${cToS([def.zoom])}.png`
  }

  let down, moveHandler = _ => _

  canvas.oncontextmenu = e => false
  canvas.onwheel = ev => {
    zoomAround(.9 ** -Math.sign(ev.deltaY), ev)
    draw()
    return false
  }
  canvas.onmousedown = event => {
    down = { event, origin: [...def.origin], moved: false}
  }
  canvas.onmouseup = event => {
    if (!down.moved) {
      zoomAround(event.which === 1 ? 0.5 : 2, event)
      draw()
    }
    down = null
  }
  canvas.onmousemove = event => {
    if (!down) return moveHandler(event)
    const { x, y, r } = getDiff(down.event, event)
    if (r < 5) return
    def.origin[0] = down.origin[0] + x * def.zoom
    def.origin[1] = down.origin[1] - y * def.zoom
    down.moved = true
    draw()
  }

  draw()

  return {
    draw,
    onMove: handler => moveHandler = handler,
    pixelLocation: (x, y) => [
      def.origin[0] + (x - half.W) * def.zoom,
      def.origin[1] - (y - half.H) * def.zoom
    ],
    setGenerator: gen => (def.generator = gen, draw())
  }
}

const saveHash = _ => {
  const newHash = '?' + [...loc(mandlDef), ...loc(juliaDef)].join(',')
  if (window.location.search !== newHash) window.history.pushState({}, '', newHash)
}

const loc = def => [def.zoom, def.origin[0], def.origin[1]]
const [mZ, mX, mY, jZ, jX, jY] = document.location.search.replace(/^\?/, '').split(',')
const mandlDef = { origin: [+mX || -0.7, +mY || 0.0], zoom: +mZ || 0.0050, generator: [0, 0] }
const juliaDef = { origin: [+jX || -0.0, +jY || 0.0], zoom: +jZ || 0.0065, generator: [+mX || -0.82, +mY || -0.2] }
const shaders = [...document.querySelectorAll('script[type=webgl]')]
const mandl = webglCanvas('mandl', shaders, mandlDef, saveHash)
const julia = webglCanvas('julia', shaders, juliaDef, saveHash)

mandl.onMove(e => julia.setGenerator(mandl.pixelLocation(e.offsetX, e.offsetY)))
document.querySelector('select').onchange = _ => (mandl.draw(), julia.draw())

</script>
</body>
</html>
